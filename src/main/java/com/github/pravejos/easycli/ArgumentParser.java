/*
 * This Java source file was generated by the Gradle 'init' task.
 */
package com.github.pravejos.easycli;

import java.lang.reflect.Field;
import java.lang.reflect.InvocationTargetException;
import java.util.HashMap;
import java.util.Map;

@SuppressWarnings("unused")
public class ArgumentParser {

  private static final String LONG_OPTION_PREFIX = "--";
  private static final String SHORT_OPTION_PREFIX = "-";

  private static Class<?> lastProcessedClass;

  public static void printHelp() {
    System.out.println(HelpTextGenerator.generateHelpText(lastProcessedClass));
  }

  public static void printHelp(Class<?> argClass) {
    System.out.println(HelpTextGenerator.generateHelpText(argClass));
  }

  /**
   * Parse the arguments.
   *
   * @param argClass The class which contains the argument definitions.
   * @param args The arguments to be parsed.
   * @param <T> The type of class having {@link Option}s defined.
   * @return The object containing the parsed arguments
   */
  public static <T> T parse(Class<T> argClass, String[] args) {
    lastProcessedClass = argClass;
    try {
      T obj = argClass.getConstructor().newInstance();
      if (args == null) {
        return obj;
      }

      Map<Option, Field> optionFieldMap = new HashMap<>();
      Map<Parameter, Field> parameterFieldMap = new HashMap<>();
      int maxParameters = 0;
      for (Field field : argClass.getDeclaredFields()) {
        field.setAccessible(true);
        if (field.isAnnotationPresent(Option.class)) {
          Option argumentDef = field.getAnnotation(Option.class);
          optionFieldMap.put(argumentDef, field);
        } else if (field.isAnnotationPresent(Parameter.class)) {
          Parameter parameter = field.getAnnotation(Parameter.class);
          parameterFieldMap.put(parameter, field);
          // TODO Add validation on whether the parameter positions are unique and incremented by 1.
          maxParameters = Math.max(parameter.position(), maxParameters);
        }
      }

      // TODO Add support for mutual exclusions.
      String arg;
      String argValue = null;
      int paramCount = 0;
      for (int i = 0; i < args.length; i++) {
        arg = args[i];
        if (arg.startsWith(LONG_OPTION_PREFIX)) {
          String optionStr;
          if (arg.contains("=")) {
            int indexEquals = arg.indexOf('=');
            argValue = arg.substring(indexEquals + 1);
            optionStr = arg.substring(2, indexEquals);
          } else {
            optionStr = arg.substring(2);
          }

          Map.Entry<Option, Field> optionFieldEntry =
                  optionFieldMap.entrySet().stream()
                          .filter(e -> e.getKey().longName().equals(optionStr))
                          .findFirst()
                          .orElseThrow(() -> new ArgumentParserException("Invalid option - " + optionStr));
          Field field = optionFieldEntry.getValue();
          if (field.getType().isAssignableFrom(Boolean.TYPE)) {
            field.setBoolean(obj, true);
          } else {
            if (!arg.contains("=")) {
              assertTrue(
                      i + 1 < args.length,
                      "Argument parsing failed. Missing value for argument - " + optionStr);
              argValue = args[++i];
            }
            setFieldValue(obj, field, argValue);
          }
          optionFieldMap.remove(optionFieldEntry.getKey());
        } else if (arg.startsWith(SHORT_OPTION_PREFIX)) {
          String optionStr;
          if (arg.contains("=")) {
            int indexEquals = arg.indexOf('=');
            argValue = arg.substring(indexEquals + 1);
            optionStr = arg.substring(1, indexEquals);
            assertTrue(
                    (optionStr.length() == 1),
                    "'" + optionStr + "' cannot be combined with '='. Split them into individual options");
          } else {
            optionStr = arg.substring(1);
          }
          boolean isSingleShortOption = (optionStr.length() == 1);
          for (int j = 0; j < optionStr.length(); j++) {
            char option = optionStr.charAt(j);
            Map.Entry<Option, Field> optionFieldEntry =
                    optionFieldMap.entrySet().stream()
                            .filter(e -> e.getKey().shortName() == option)
                            .findFirst()
                            .orElseThrow(
                                    () -> new ArgumentParserException("Invalid option - " + optionStr));
            Field field = optionFieldEntry.getValue();
            assertTrue(
                isSingleShortOption || field.getType().isAssignableFrom(Boolean.TYPE),
                "Only boolean options can be combined together. Invalid option '" + option + "'");
            if (field.getType().isAssignableFrom(Boolean.TYPE)) {
              field.setBoolean(obj, true);
            } else {
              if (!arg.contains("=")) {
                assertTrue(
                        i + 1 < args.length,
                        "Argument parsing failed. Missing value for argument - " + optionStr);
                argValue = args[++i];
              }
              setFieldValue(obj, field, argValue);
            }
            optionFieldMap.remove(optionFieldEntry.getKey());
          }
        } else { // Process parameters
          // Validate that no more options are present.
          assertTrue(verifyOptionsCompleted(args, i), "Options should be defined before arguments");
          int paramPosition = ++paramCount;
          Map.Entry<Parameter, Field> parameterFieldEntry =
              parameterFieldMap.entrySet().stream()
                  .filter(e -> (e.getKey().position() == paramPosition))
                  .findFirst()
                  .orElseThrow(
                      () ->
                          new ArgumentParserException(
                              "No parameter defined for position " + paramPosition));
          setFieldValue(obj, parameterFieldEntry.getValue(), arg);
          parameterFieldMap.remove(parameterFieldEntry.getKey());
        }
      }

      // Process unused options and parameters and set default value.
      for (Map.Entry<Option, Field> optionFieldEntry : optionFieldMap.entrySet()) {
        Option option = optionFieldEntry.getKey();
        Field field = optionFieldEntry.getValue();
        String defaultValue = option.defaultValue();
        if (!defaultValue.isEmpty()) {
          setFieldValue(obj, field, option.defaultValue());
        }
      }

      // Process unused options and parameters and set default value.
      for (Map.Entry<Parameter, Field> parameterFieldEntry : parameterFieldMap.entrySet()) {
        Parameter parameter = parameterFieldEntry.getKey();
        Field field = parameterFieldEntry.getValue();

        if (parameter.required()) {
          throw new ArgumentParserException("Missing required parameter - " + field.getName());
        }
        String defaultValue = parameter.defaultValue();
        if (!defaultValue.isEmpty()) {
          setFieldValue(obj, field, parameter.defaultValue());
        }
      }

      return obj;
    } catch (InstantiationException
        | IllegalAccessException
        | InvocationTargetException
        | NoSuchMethodException e) {
      throw new ArgumentParserException("Unknown error - " + e.getMessage());
    }
  }

  private static boolean verifyOptionsCompleted(String[] args, int startIndex) {
    for (int i = startIndex + 1; i < args.length; i++) {
      if (args[i].startsWith(SHORT_OPTION_PREFIX)) {
        return false;
      }
    }

    return true;
  }

  private static <T> void setFieldValue(T obj, Field field, String argValue)
      throws IllegalAccessException {
    if (field.getType().isAssignableFrom(String.class)) {
      field.set(obj, argValue);
    } else if (field.getType().isAssignableFrom(Long.TYPE)) {
      field.setLong(obj, Long.parseLong(argValue));
    } else if (field.getType().isAssignableFrom(Integer.TYPE)) {
      field.setInt(obj, Integer.parseInt(argValue));
    } else if (field.getType().isAssignableFrom(Boolean.TYPE)) {
      field.setBoolean(obj, Boolean.parseBoolean(argValue));
    } else if (field.getType().isAssignableFrom(Character.TYPE)) {
      assertTrue(argValue.length() == 1, "Invalid option value - " + argValue);
      field.setChar(obj, argValue.charAt(0));
    } else if (field.getType().isAssignableFrom(Double.TYPE)) {
      field.setDouble(obj, Double.parseDouble(argValue));
    } else if (field.getType().isAssignableFrom(Float.TYPE)) {
      field.setFloat(obj, Float.parseFloat(argValue));
    } else if (field.getType().isAssignableFrom(Short.TYPE)) {
      field.setShort(obj, Short.parseShort(argValue));
    }
  }

  private static void assertTrue(boolean b, String errorMessage) {
    if (!b) {
      throw new ArgumentParserException(errorMessage);
    }
  }
}
